#! /usr/bin/env stap
/**
 * This is the primary Systemtap script for logging connection info. It outputs
 * in a CSV format. Currently it works with Ubuntu 18.04 only as some syscalls
 * have changed since the 16.04 kernel. We track statistics per connection with
 * a number of global arrays, assuming that each thread handles one connection
 * at a time.
 */
global connect, ip, p, file, mem, fault, clock
//global req, fault, file, clock, mem, time, connect, ip, p, call_time

// __fd_install and __fd_close syscalls open and close file descriptors
probe kernel.function("__fd_install").call {
  if(execname() == "apache2")
    file[tid()]++
}
probe kernel.function("__close_fd").call {
  if(execname() == "apache2")
    file[tid()]--
}
// Tracks pagefaults during per thread
probe vm.pagefault {
  if(execname() == "apache2")
    fault[tid()]++
}
// These three syscalls map and unmap memory for a thread. They were mentioned
// in the COGO paper. length in this case is in pages allocated.
probe vm.mmap {
  if(execname() == "apache2")
    mem[tid()] += length
}
probe syscall.mmap2 {
  if(execname() == "apache2")
    mem[tid()] += length
}
probe vm.munmap {
  if(execname() == "apache2")
    mem[tid()] -= length
}

// We log any network in/out traffic and match it with the thread. This includes
// but is not limited to Apache traffic.
probe netfilter.ip.local_in {
  ip[tid()] = saddr
  p[tid()] = sport
  connect[tid()] = 1
}
probe netfilter.ip.local_out {
  ip[tid()] = daddr
  p[tid()] = dport
  connect[tid()] = 1
}


probe netfilter.ip.local_out {
  ip[tid()] = saddr
  p[tid()] = sport
  connect[tid()] = 1
}


probe tcp.sendmsg {
  ip[tid()] = daddr
  p[tid()] = dport
  connect[tid()] = 1
}



probe tcp.receive, tcp.recvmsg, socket.receive, tcp.setsockopt {
  if(saddr != "0000:0000:0000:0000:0000:ffff:0a01:0102" && saddr != "10.1.1.2" && sport!= 0)
  {
  //printf("PP %6d %16s \n",sport,saddr)
  ip[tid()] = saddr
  p[tid()] = sport
  connect[tid()] = 1
  }
  else if(daddr != "0000:0000:0000:0000:0000:ffff:0a01:0102" && daddr != "10.1.1.2" && dport!= 0)
  {
  //printf("PP %6d %16s \n",dport,daddr)
  ip[tid()] = daddr
  p[tid()] = dport 
  connect[tid()] = 1

  }

}


// We probe each TCP connection whenever accept() call occurs
probe kernel.function("tcp_accept").return?,
      kernel.function("inet_csk_accept").return?,
      kernel.function("tcp_connect").return?,
      kernel.function("tcp_write").return?,
      kernel.function("tcp_sent").return?,
      kernel.function("tcp_recv").return?,
      kernel.function("tcp_recved").return?,
      kernel.function("tcp_poll").return?,
      //kernel.function("tcp_close").return?,
      kernel.function("tcp_abort").return?, 
      kernel.function("tcp_listen").return? {
  sock = $return
  if (sock != 0 && inet_get_ip_source(sock) != "0000:0000:0000:0000:0000:ffff:0a01:0102")
  { 
    //printf("DEBUG %6d %16s %6d %6d %16s\n", uid(), execname(), pid(),inet_get_local_port(sock), inet_get_ip_source(sock))
    ip[tid()] = inet_get_ip_source(sock)
    p[tid()] = inet_get_local_port(sock)
    connect[tid()] = 1
  } 
    
}


// When the call returns, we output the all the data we currently have on the thread
// and the syscall itself. If there is an active connection at this time, we also show
// the remote IP and port. When the connection closes, we clear all values related to
// the conenction so we can get accurate per-connection statistics.
probe kernel.function("*@net/socket.c").return {
  if(execname() == "apache2" || execname() == "nginx") {
    if(connect[tid()] == 1)
    {
      cur = get_cycles()
      diff = cur - clock[tid()]
      clock[tid()] = cur
      printf("%s,%d,%d,%d,%s,%d,%d,%d,%d,%d\n", ppfunc(), gettimeofday_us(), tid(), pid(), ip[tid()], p[tid()],mem[tid()], fault[tid()], file[tid()],diff)
    }
    else
      printf("%s,%d,%d,%d,-1,-1,%d,%d,%d,0\n", ppfunc(), gettimeofday_us(), tid(), pid(), mem[tid()], fault[tid()], file[tid()])
  
    if(ppfunc() == "SyS_shutdown" || ppfunc() == "sock_destroy_inode") {
      delete connect[tid()]
      delete ip[tid()]
      delete p[tid()]
      delete mem[tid()]
      delete fault[tid()]
      delete file[tid()]
      delete clock[tid()]
    }
  }
}


// When a connection is accepted, we clear all values so we can get accurate
// per-connection statistics
probe kernel.function("SyS_accept4").call {
  if(execname() == "apache2") {
    fault[tid()] = 0
    file[tid()] = 0
    clock[tid()] = get_cycles()
    mem[tid()] = 0
  }
}




// Print out the CSV header when the probe begins
probe begin {
  printf("func,timestamp,tid,pid,addr,port,memory,fault,filedesc,cycles\n")
}
